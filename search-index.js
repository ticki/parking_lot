var searchIndex = {};
searchIndex["parking_lot"] = {"doc":"This library provides implementations of `Mutex`, `RwLock`, `Condvar` and `Once` that are smaller, faster and more flexible than those in the Rust standard library. It also provides a `ReentrantMutex` type.","items":[[3,"Once","parking_lot","A synchronization primitive which can be used to run a one-time initialization. Useful for one-time initialization for globals, FFI or related functionality.",null,null],[3,"OnceState","","State yielded to the `call_once_force` method which can be used to query whether the `Once` was previously poisoned or not.",null,null],[3,"Mutex","","A mutual exclusion primitive useful for protecting shared data",null,null],[3,"MutexGuard","","An RAII implementation of a \"scoped lock\" of a mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.",null,null],[3,"ReentrantMutex","","A mutex which can be recursively locked by a single thread.",null,null],[3,"ReentrantMutexGuard","","An RAII implementation of a \"scoped lock\" of a reentrant mutex. When this structure is dropped (falls out of scope), the lock will be unlocked.",null,null],[3,"Condvar","","A Condition Variable",null,null],[3,"WaitTimeoutResult","","A type indicating whether a timed wait on a condition variable returned due to a time out or not.",null,null],[3,"RwLock","","A reader-writer lock",null,null],[3,"RwLockReadGuard","","RAII structure used to release the shared read access of a lock when dropped.",null,null],[3,"RwLockWriteGuard","","RAII structure used to release the exclusive write access of a lock when dropped.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"waittimeoutresult"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"waittimeoutresult"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"waittimeoutresult"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"timed_out","","Returns whether the wait was known to have timed out.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Creates a new condition variable which is ready to be waited on and notified.",1,{"inputs":[],"output":{"name":"condvar"}}],[11,"notify_one","","Wakes up one blocked thread on this condvar.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"notify_all","","Wakes up all blocked threads on this condvar.",1,{"inputs":[{"name":"self"}],"output":null}],[11,"wait","","Blocks the current thread until this condition variable receives a notification.",1,{"inputs":[{"name":"self"},{"name":"mutexguard"}],"output":null}],[11,"wait_until","","Waits on this condition variable for a notification, timing out after the specified time instant.",1,{"inputs":[{"name":"self"},{"name":"mutexguard"},{"name":"instant"}],"output":{"name":"waittimeoutresult"}}],[11,"wait_for","","Waits on this condition variable for a notification, timing out after a specified duration.",1,{"inputs":[{"name":"self"},{"name":"mutexguard"},{"name":"duration"}],"output":{"name":"waittimeoutresult"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"condvar"}}],[11,"new","","Creates a new mutex in an unlocked state ready for use.",2,{"inputs":[{"name":"t"}],"output":{"name":"mutex"}}],[11,"into_inner","","Consumes this mutex, returning the underlying data.",2,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"lock","","Acquires a mutex, blocking the current thread until it is able to do so.",2,{"inputs":[{"name":"self"}],"output":{"name":"mutexguard"}}],[11,"try_lock","","Attempts to acquire this lock.",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_lock_for","","Attempts to acquire this lock until a timeout is reached.",2,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"try_lock_until","","Attempts to acquire this lock until a timeout is reached.",2,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"option"}}],[11,"get_mut","","Returns a mutable reference to the underlying data.",2,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"raw_unlock","","Releases the mutex.",2,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_unlock_fair","","Releases the mutex using a fair unlock protocol.",2,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_lock","","Acquires a mutex, blocking the current thread until it is able to do so.",2,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_try_lock","","Attempts to acquire this lock.",2,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default","","",2,{"inputs":[],"output":{"name":"mutex"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"unlock_fair","","Unlocks the mutex using a fair unlock protocol.",3,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",3,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",3,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Creates a new reentrant mutex in an unlocked state ready for use.",4,{"inputs":[{"name":"t"}],"output":{"name":"reentrantmutex"}}],[11,"into_inner","","Consumes this reentrant mutex, returning the underlying data.",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"lock","","Acquires a reentrant mutex, blocking the current thread until it is able to do so.",4,{"inputs":[{"name":"self"}],"output":{"name":"reentrantmutexguard"}}],[11,"try_lock","","Attempts to acquire this lock.",4,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_lock_for","","Attempts to acquire this lock until a timeout is reached.",4,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"try_lock_until","","Attempts to acquire this lock until a timeout is reached.",4,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"option"}}],[11,"get_mut","","Returns a mutable reference to the underlying data.",4,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"raw_unlock","","Releases the mutex.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_unlock_fair","","Releases the mutex using a fair unlock protocol.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_lock","","Acquires a mutex, blocking the current thread until it is able to do so.",4,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_try_lock","","Attempts to acquire this lock.",4,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"reentrantmutex"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"unlock_fair","","Unlocks the mutex using a fair unlock protocol.",5,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",5,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",5,{"inputs":[{"name":"self"}],"output":null}],[11,"new","","Creates a new instance of an `RwLock<T>` which is unlocked.",6,{"inputs":[{"name":"t"}],"output":{"name":"rwlock"}}],[11,"into_inner","","Consumes this `RwLock`, returning the underlying data.",6,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"read","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",6,{"inputs":[{"name":"self"}],"output":{"name":"rwlockreadguard"}}],[11,"try_read","","Attempts to acquire this rwlock with shared read access.",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_read_for","","Attempts to acquire this rwlock with shared read access until a timeout is reached.",6,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"try_read_until","","Attempts to acquire this rwlock with shared read access until a timeout is reached.",6,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"option"}}],[11,"write","","Locks this rwlock with exclusive write access, blocking the current thread until it can be acquired.",6,{"inputs":[{"name":"self"}],"output":{"name":"rwlockwriteguard"}}],[11,"try_write","","Attempts to lock this rwlock with exclusive write access.",6,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"try_write_for","","Attempts to acquire this rwlock with exclusive write access until a timeout is reached.",6,{"inputs":[{"name":"self"},{"name":"duration"}],"output":{"name":"option"}}],[11,"try_write_until","","Attempts to acquire this rwlock with exclusive write access until a timeout is reached.",6,{"inputs":[{"name":"self"},{"name":"instant"}],"output":{"name":"option"}}],[11,"get_mut","","Returns a mutable reference to the underlying data.",6,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"raw_unlock_read","","Releases shared read access of the rwlock.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_unlock_write","","Releases exclusive write access of the rwlock.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_unlock_read_fair","","Releases shared read access of the rwlock using a fair unlock protocol.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_unlock_write_fair","","Releases exclusive write access of the rwlock using a fair unlock protocol.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_downgrade","","Atomically downgrades a write lock into a read lock without allowing any writers to take exclusive access of the lock in the meantime.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_read","","Locks this rwlock with shared read access, blocking the current thread until it can be acquired.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_try_read","","Attempts to acquire this rwlock with shared read access.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"raw_write","","Locks this rwlock with exclusive write access, blocking the current thread until it can be acquired.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"raw_try_write","","Attempts to lock this rwlock with exclusive write access.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"default","","",6,{"inputs":[],"output":{"name":"rwlock"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",7,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",7,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",7,{"inputs":[{"name":"self"}],"output":null}],[11,"downgrade","","Atomically downgrades a write lock into a read lock without allowing any writers to take exclusive access of the lock in the meantime.",8,{"inputs":[{"name":"self"}],"output":{"name":"rwlockreadguard"}}],[11,"unlock_fair","","Unlocks the `RwLock` using a fair unlock protocol.",8,{"inputs":[{"name":"self"}],"output":null}],[11,"deref","","",8,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"deref_mut","","",8,{"inputs":[{"name":"self"}],"output":{"name":"t"}}],[11,"drop","","",8,{"inputs":[{"name":"self"}],"output":null}],[11,"poisoned","","Returns whether the associated `Once` has been poisoned.",9,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"new","","Creates a new `Once` value.",10,{"inputs":[],"output":{"name":"once"}}],[11,"call_once","","Performs an initialization routine once and only once. The given closure will be executed if this is the first time `call_once` has been called, and otherwise the routine will *not* be invoked.",10,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"call_once_force","","Performs the same function as `call_once` except ignores poisoning.",10,{"inputs":[{"name":"self"},{"name":"f"}],"output":null}],[11,"default","","",10,{"inputs":[],"output":{"name":"once"}}],[6,"MutexGuardRef","","Typedef of an owning reference that uses a `MutexGuard` as the owner.",null,null],[6,"ReentrantMutexGuardRef","","Typedef of an owning reference that uses a `ReentrantMutexGuard` as the owner.",null,null],[6,"RwLockReadGuardRef","","Typedef of an owning reference that uses a `RwLockReadGuard` as the owner.",null,null],[6,"RwLockWriteGuardRef","","Typedef of an owning reference that uses a `RwLockWriteGuard` as the owner.",null,null],[17,"ONCE_INIT","","Initialization value for static `Once` values.",null,null]],"paths":[[3,"WaitTimeoutResult"],[3,"Condvar"],[3,"Mutex"],[3,"MutexGuard"],[3,"ReentrantMutex"],[3,"ReentrantMutexGuard"],[3,"RwLock"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"],[3,"OnceState"],[3,"Once"]]};
searchIndex["parking_lot_core"] = {"doc":"This library exposes a low-level API for creating your own efficient synchronization primitives.","items":[[3,"UnparkResult","parking_lot_core","Result of an unpark operation.",null,null],[12,"unparked_threads","","The number of threads that were unparked.",0,null],[12,"have_more_threads","","Whether there are any threads remaining in the queue. This only returns true if a thread was unparked.",0,null],[12,"be_fair","","This is set to true on average once every 0.5ms for any given key. It should be used to switch to a fair unlocking mechanism for a particular unlock.",0,null],[3,"UnparkToken","","A value which is passed from an unparker to a parked thread.",null,null],[12,"0","","",1,null],[3,"ParkToken","","A value associated with a parked thread which can be used by `unpark_filter`.",null,null],[12,"0","","",2,null],[3,"SpinWait","","A counter used to perform exponential backoff in spin loops.",null,null],[4,"ParkResult","","Result of a park operation.",null,null],[13,"Unparked","","We were unparked by another thread with the given token.",3,null],[13,"Invalid","","The validation callback returned false.",3,null],[13,"TimedOut","","The timeout expired.",3,null],[4,"RequeueOp","","Operation that `unpark_requeue` should perform.",null,null],[13,"Abort","","Abort the operation without doing anything.",4,null],[13,"UnparkOneRequeueRest","","Unpark one thread and requeue the rest onto the target queue.",4,null],[13,"RequeueAll","","Requeue all threads onto the target queue.",4,null],[4,"FilterOp","","Operation that `unpark_filter` should perform for each thread.",null,null],[13,"Unpark","","Unpark the thread and continue scanning the list of parked threads.",5,null],[13,"Skip","","Don't unpark the thread and continue scanning the list of parked threads.",5,null],[13,"Stop","","Don't unpark the thread and stop scanning the list of parked threads.",5,null],[5,"park","","Parks the current thread in the queue associated with the given key.",null,{"inputs":[{"name":"usize"},{"name":"v"},{"name":"b"},{"name":"t"},{"name":"parktoken"},{"name":"option"}],"output":{"name":"parkresult"}}],[5,"unpark_one","","Unparks one thread from the queue associated with the given key.",null,{"inputs":[{"name":"usize"},{"name":"c"}],"output":{"name":"unparkresult"}}],[5,"unpark_all","","Unparks all threads in the queue associated with the given key.",null,{"inputs":[{"name":"usize"},{"name":"unparktoken"}],"output":{"name":"usize"}}],[5,"unpark_requeue","","Removes all threads from the queue associated with `key_from`, optionally unparks the first one and requeues the rest onto the queue associated with `key_to`.",null,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"v"},{"name":"c"}],"output":{"name":"unparkresult"}}],[5,"unpark_filter","","Unparks a number of threads from the front of the queue associated with `key` depending on the results of a filter function which inspects the `ParkToken` associated with each thread.",null,{"inputs":[{"name":"usize"},{"name":"f"},{"name":"c"}],"output":{"name":"unparkresult"}}],[11,"new","","Creates a new `SpinWait`.",6,{"inputs":[],"output":{"name":"spinwait"}}],[11,"reset","","Resets a `SpinWait` to its initial state.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"spin","","Spins until the sleep threshold has been reached.",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"spin_no_yield","","Spins without yielding the thread to the OS.",6,{"inputs":[{"name":"self"}],"output":null}],[11,"default","","",6,{"inputs":[],"output":{"name":"spinwait"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"parkresult"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"self"},{"name":"parkresult"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"parkresult"}}],[11,"is_unparked","","Returns true if we were unparked by another thread.",3,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"unparkresult"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"unparkresult"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"unparkresult"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",4,{"inputs":[{"name":"self"},{"name":"requeueop"}],"output":{"name":"bool"}}],[11,"clone","","",4,{"inputs":[{"name":"self"}],"output":{"name":"requeueop"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",5,{"inputs":[{"name":"self"},{"name":"filterop"}],"output":{"name":"bool"}}],[11,"clone","","",5,{"inputs":[{"name":"self"}],"output":{"name":"filterop"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"unparktoken"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"unparktoken"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"unparktoken"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"parktoken"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"parktoken"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"parktoken"}}],[17,"DEFAULT_UNPARK_TOKEN","","A default unpark token to use.",null,null],[17,"DEFAULT_PARK_TOKEN","","A default park token to use.",null,null]],"paths":[[3,"UnparkResult"],[3,"UnparkToken"],[3,"ParkToken"],[4,"ParkResult"],[4,"RequeueOp"],[4,"FilterOp"],[3,"SpinWait"]]};
initSearch(searchIndex);
